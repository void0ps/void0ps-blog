---
title: 自删除
date: 2025-11-21
tags:
  - evasion
description: ""
draft: false
---

# 解决自删除在24H2版本中适配问题

在 Windows 中，程序启动时，系统会通过 **内存映射文件（Memory Mapped File）** 将 EXE 文件加载到内存中。

- 当程序运行后，它使用的是**内存中的副本**，而不是直接执行磁盘文件。
    
- 这意味着，只要不再访问磁盘文件本身，理论上你可以删除磁盘上的原始文件而不会影响正在运行的进程。
    

在 Windows 10 及更早版本，这种删除是直接彻底删除的。  
在 **Windows 11 24H2**，NTFS 新加了保护机制，普通 `SetFileInformationByHandle` 会失败，所以必须使用你代码中实现的 **POSIX 语义删除**。

## 总体流程

1. **获取当前进程的 EXE 文件路径**  
    使用 `GetModuleFileNameW` 获取当前运行程序的完整路径。
    
2. **打开当前文件句柄**  
    使用 `CreateFileW` 以 `DELETE` 权限打开。
    
3. **将默认数据流 `:$DATA` 重命名为自定义 ADS（Alternate Data Stream）**  
    通过 `SetFileInformationByHandle(FileRenameInfo)` 重命名为 `:$delete` 之类的流。
    
4. **关闭第一个句柄，重新以 `DELETE` 权限打开文件**  
    这是为了确保后续删除操作生效。
    
5. **设置 POSIX 删除标记**  
    使用 `SetFileInformationByHandle(FileDispositionInfoEx)`，并设置标记：
    
    `FILE_DISPOSITION_FLAG_DELETE | FILE_DISPOSITION_FLAG_POSIX_SEMANTICS`
    
6. **关闭句柄触发删除**  
    当句柄关闭时，文件被标记删除，但进程仍然继续在内存中运行。
    
7. **验证文件是否已删除**  
    调用 `PathFileExistsW` 检查路径是否还存在。


## 代码

```c
#include<Windows.h>
#include<stdio.h>
#include<stdlib.h>

BOOL FileExists(LPCWSTR path) {
	DWORD attr = GetFileAttributesW(path);
	return (attr != INVALID_FILE_ATTRIBUTES && !(attr & FILE_ATTRIBUTE_DIRECTORY));
}

BOOL SeleDelete() {
	HANDLE hFile = INVALID_HANDLE_VALUE;
	WCHAR Path[MAX_PATH * 2];
	//获得当前文件路径
	if (!GetModuleFileNameW(NULL, Path, MAX_PATH * 2)) {
		printf("GetModuleFileNameW Failed with Error :%d\n", GetLastError());
		return FALSE;
	}
	//以DELETE标志创建文件句柄
	if ((hFile = CreateFileW(Path, DELETE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
		printf("CreateFileW Failed with Error :%d\n", GetLastError());
		return FALSE;
	}
	//重命名文件流名称
	LPCWSTR lpwStream = L":ajie";
	PFILE_RENAME_INFO pRename = (PFILE_RENAME_INFO)malloc(sizeof(FILE_RENAME_INFO) + sizeof(WCHAR) * wcslen(lpwStream));
	if (pRename == NULL) {
		printf("malloc Failed with Error :%d\n", GetLastError());
		return FALSE;
	}
	//填充PFILE_RENAME_INFO结构体
	RtlSecureZeroMemory(pRename, sizeof(FILE_RENAME_INFO) + sizeof(WCHAR) * wcslen(lpwStream));

	pRename->FileNameLength = (DWORD)(sizeof(WCHAR) * wcslen(lpwStream));

	RtlCopyMemory(pRename->FileName, lpwStream, sizeof(WCHAR) * (wcslen(lpwStream) + 1));
	//设置重命名文件流
	if (!SetFileInformationByHandle(hFile, FileRenameInfo, pRename, sizeof(FILE_RENAME_INFO) + sizeof(WCHAR) * wcslen(lpwStream))) {
		printf("SetFileInformationByHandle Failed with Error :%d\n", GetLastError());
		return FALSE;
	}
	//关闭文件句柄这是为了确保后续删除操作生效
	CloseHandle(hFile);
	free(pRename);
	pRename = NULL;
	//重新打开文件句柄（DELETE）
	hFile = CreateFileW(Path, DELETE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("CreateFileW2 Failed with Error :%d\n", GetLastError());
		return FALSE;
	}
	//设置 POSIX 删除标记
	FILE_DISPOSITION_INFO_EX fDeleteEx;
	RtlSecureZeroMemory(&fDeleteEx, sizeof(fDeleteEx));
	fDeleteEx.Flags = FILE_DISPOSITION_FLAG_DELETE | FILE_DISPOSITION_FLAG_POSIX_SEMANTICS;

	if (!SetFileInformationByHandle(hFile, FileDispositionInfoEx, &fDeleteEx, sizeof(fDeleteEx))) {
		printf("failed to set delete deposition\n");
		return FALSE;
	}
	CloseHandle(hFile); //关闭句柄触发删除
	if (FileExists(Path)) {
		printf("failed to delete copy, file still exists\n");
		return FALSE;
	}
	return TRUE;
}

int main() {
	if (!SeleDelete()) {
		printf("SelfDelete Failed\n");
		return 1;
	} {
		printf("SelfDelete Successfully\n");
		getchar();
	}
	
	return 0;
}

```